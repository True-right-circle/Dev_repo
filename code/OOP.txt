절차지향 vs 객체지향

절차지향(Procedure) -> 함수나 로직들을 순서대로 실행시키는 방법 
:함수의 호출 순서가 중요하다.
: 직관적인 장점이 있으나 프로그램의 규모가 커질수록 복잡하고 유지보수가 어렵다

객체지향(object oriented programming) -> 객체 지향 개발 방법
객체 : 속성(Data 해당 객체가 같은 값들 ), 기능(Method 해당 객체가 수행하는 기능들)

ex)
class Knigt
{
    //속성
    public int hp;
    public int attack;

    //기능 1
    public void Move()
    {

    }

    //기능 2
    public void fight()
    {

    }
}

Knigt k = new Knigt(); -> 객체를 생성
//생성한 객체의 속성 할당 및 기능 수행
k.hp =100;
k.move();


/-----------------------------------------------------/
value and reference 얕은복사 깊은복사

stuct vs class
-> stuct는 복사를 하는것이고 class는 참조를 하는것이다
함수에 인자로 넘길 경우
class는 참조를 하기 떄문에 본체(?)의 값에 변화를 주면 값이 변하고
struct는 복사를 하기 때문에 본체의 값에 영향을 주지 않는다.

Test code

struct Maage
{
    hp
}

class Knight
{
    hp
}

Mage mage1;
mage.hp = 100;

Mage mage2=mage1;
mage.hp = 50;
-------------------> mage2 = mage1는 복사가 일어나 hp는 각각 100,50으로 서로 다른 객체이다.

Knight k1;
k1.hp = 100;

Knight k2 = k1;
k2.hp = 50;
-------------------> k2는 k1을 참조하기 때문에 k1의 hp를 바꿔버려 50이 되어 버린다.
별도의 Knight를 하려면
Knight k2 = new k2();로 생성해야한다.

*Deep Copy
클래스에 해당 오브젝트를 반환하는 객체를 만들어분다
public Knight Clone()
{
    Knight k = new k();
    k.hp = hp;
    reutun k;
}
->
Knight k1;
k1.hp = 100;

Knight k2 = k1.Clone();
k2.hp = 50;
-------------------> k1과 같은 값을 같는 새로운 객체를 Clone한 값이 새로 k2에 할당 되기 때문에
복사가 일어나 각각 별개의 오브젝트가 된다.
/-----------------------------------------------------/


/-----------------------------------------------------/
메모리
 프로그램이 실행이 되면 OS는 프로그램을 실행 할 수 있는 메모리를 할당한다.
- 스택, 힙
 스택 : 불완정하고 임시적으로 사용하는 메모리이다.
 잠깐만 필요한 메모리 -> 
 어떠한 f라는 함수를 호출 할 때 함수안에 로컬 변수는 함수 내에서 연산이 일어난 후
 함수가 끝나면 사라진다. -> 이러한 상황에 스택이 사용 된다.
 함수를 실행하기 위한 메모장 같은 존재할(함수안에 실행되는 변수들은 스택에 올라간다.)

 mage경우 구조체 복사 타입이고 Knight는 class 참조 타입이다.
 ->mage 경우 선언시 크기만큼 stack에 쌓인다
 ->Knight는 선언시 헤딩 메모리의 주소가 stack에 쌓인다.
 ->Knight의 본래의 값은 heap에 올라가며 해당 주소가 stack에 쌓인다
new로 생성시 본체는 heap에 올라가며 stack에는 본체를 가르키는 주소값이 올라간다.
만약 k2 = k1과 같은 할당을 했으면 k2는 k1이 가르키는 주소를 같이 할당받는것이다.

stack영역은 함수가 실행되는 순간부터 함수가 종료되는 구간까지 계속
본인이 사용하는 stack공간을 추적을 한다. -> 함수 호출이 종료되는 순간에 알아서 할당 해제가 일어나 관리가 
잘된다.

heap영역 같은 경우에는 메모리를 할당을 했으면 별다른 행동을 하지 않으면 해체없이 계속 heap에 계속 쌓이기 때문에
cpp같은 경우에는 개발자가 수동으로 메모리 해제를 해야하지만 c#같은 경우엔 GC가 알아서 메모리 해제를 하는 역할을한다.

*참조 타입은 무조건 힙을 가르키는것은 아니다.
구조체 타입을 ref등으로 참조식으로 사용할 경우 
주소를 가르키는 구조는 같으나 본체는 stack영역에 있을 수 있기 때문에
stack내의 영역의 주소를 가르킬 수도 있다.
