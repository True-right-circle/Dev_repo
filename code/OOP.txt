절차지향 vs 객체지향

절차지향(Procedure) -> 함수나 로직들을 순서대로 실행시키는 방법 
:함수의 호출 순서가 중요하다.
: 직관적인 장점이 있으나 프로그램의 규모가 커질수록 복잡하고 유지보수가 어렵다

객체지향(object oriented programming) -> 객체 지향 개발 방법
객체 : 속성(Data 해당 객체가 같은 값들 ), 기능(Method 해당 객체가 수행하는 기능들)

ex)
class Knigt
{
    //속성
    public int hp;
    public int attack;

    //기능 1
    public void Move()
    {

    }

    //기능 2
    public void fight()
    {

    }
}

Knigt k = new Knigt(); -> 객체를 생성
//생성한 객체의 속성 할당 및 기능 수행
k.hp =100;
k.move();


/-----------------------------------------------------/
value and reference 얕은복사 깊은복사

stuct vs class
-> stuct는 복사를 하는것이고 class는 참조를 하는것이다
함수에 인자로 넘길 경우
class는 참조를 하기 떄문에 본체(?)의 값에 변화를 주면 값이 변하고
struct는 복사를 하기 때문에 본체의 값에 영향을 주지 않는다.

Test code

struct Maage
{
    hp
}

class Knight
{
    hp
}

Mage mage1;
mage.hp = 100;

Mage mage2=mage1;
mage.hp = 50;
-------------------> mage2 = mage1는 복사가 일어나 hp는 각각 100,50으로 서로 다른 객체이다.

Knight k1;
k1.hp = 100;

Knight k2 = k1;
k2.hp = 50;
-------------------> k2는 k1을 참조하기 때문에 k1의 hp를 바꿔버려 50이 되어 버린다.
별도의 Knight를 하려면
Knight k2 = new k2();로 생성해야한다.

*Deep Copy
클래스에 해당 오브젝트를 반환하는 객체를 만들어분다
public Knight Clone()
{
    Knight k = new k();
    k.hp = hp;
    reutun k;
}
->
Knight k1;
k1.hp = 100;

Knight k2 = k1.Clone();
k2.hp = 50;
-------------------> k1과 같은 값을 같는 새로운 객체를 Clone한 값이 새로 k2에 할당 되기 때문에
복사가 일어나 각각 별개의 오브젝트가 된다.
/-----------------------------------------------------/
